<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Java设计模式——工厂模式</title>
  </head>
  <body>
    <h1>
	简介
</h1>
<p>
	概念：实例化对象，用工厂方法代替new操作。工厂模式包括工厂方法模式和抽象工厂模式。抽象工厂模式是工厂方法模式的扩展。
</p>
<p>
	意图：定义一个接口来创建对象，但是让子类来决定哪些类需要被实例化。工厂方法把实例化的工作推迟到子类中去实现。
</p>
<p>
	适用情况：有一组类似的对象需要创建。在编码时不能预见需要创建哪种类的实例。系统需要考虑扩展性，不应依赖于产品类实例如何被创建、组合和表达的细节。
</p>
<p>
	实现的核心：多态（父类对象指向子类实例）。
</p>
<p>
	主要目的：降低耦合。
</p>
<p>
	工厂模式的任务是实例化对象，代替new操作，但是平时里我们不是经常用到new的么？这么说是没错，平日里自己做练习，写测试，你再写十几个类专门写个工厂模式，除非是在练习工厂模式，否则，YBB，呵呵。但是，在实际的项目中，new操作是少见的，假如，项目初期，有个类叫LogUtil，项目中几乎所有的类中都使用new实例化了这个类，然而有一天，项目组感觉这个名字不好，要改成LogsUtil……好，不就百十来个么，小意思，我一天就修改完了。然后第二天，冒着两个黑眼圈参加讨论的时候，项目组一致同意，将LogsUtil命名为LogsUtils……
</p>
<h1>
	简单工厂
</h1>
<p>
	上面的小例子中LogUtil如果是用简单工厂进行实例化，那么修改个类名也就是几秒钟的事：
</p>
<p>
</p>
<pre name="code" class="java">//定制抽象产品接口
public interface ILogUtil {
 
}
//定制具体产品子类
public class LogUtil4DB  implementsILogUtil {
 
 
}
public class LogUtil4File  implementsILogUtil {
 
 
}
public class LogUtil implements ILogUtil {
&lt;spanstyle=&quot;white-space:pre&quot;&gt;     &lt;/span&gt;
}
//简单工厂类：它是一个具体的类，非接口或抽象类。其中一个重要的create()方法，利用if…else或switch开关创建所需产品，并返回。
//其中create()方法通常是静态的，所以也称为静态工厂。
public class LogUtilSimpleFactory {
private static final String FORDB =&quot;logutil4db&quot;;
private static final String FORFILE =&quot;logutil4file&quot;;
private static final String LOGUTIL =&quot;logutil&quot;;
 
public static ILogUtil create(String mark){
ILogUtil obj = null;
if(mark.equals(FORDB)){
obj = new LogUtil4DB();
}else if(mark.equals(FORFILE)){
obj = new LogUtil4File();
}else if(mark.equals(LOGUTIL)){
obj = new LogUtil();
}
return obj;
}
}</pre>
此时，只要修改LogUtil类的类名及工厂中的类名就可以了（当然，这个场景有点不合适，现在的编辑器大多可以在重命名类的时候将关联的地方一同修改，就这样理解）
<p>
</p>
<h1>
	工厂方法模式
</h1>
<p>
	工厂方法模式与简单工厂模式类似，但是较之多了一层：抽象工厂；还是拿上面的例子来说，产品没有变，但是工厂多了一个上层：总部（一般是接口后抽象类，规定具体的工厂应该实现哪些方法），比如，富士康有很多的加工部门，但是每个具体的加工厂肯定是有一个总部来告诉它加工什么，怎么加工就是具体工厂的事了。上面例子中IlogUtil及其子类不变，变的是工厂类：
</p>
<p>
</p>
<pre name="code" class="java">//抽象工厂（总部；规定继承该抽象类的具体工厂的职能是create，产品是ILogUtil）
public abstract classAbstractLogUtilFactory {
         publicabstract ILogUtil create();
}
//具体工厂，生产LogUtil
public class LogUtilFactory extendsAbstractLogUtilFactory {
 
 
@Override
public ILogUtil create() {
return new LogUtil();
}
}
//具体工厂，生产LogUtil4DB
public class LogUtil4DBFactory extendsAbstractLogUtilFactory {
@Override
public ILogUtil create() {
return new LogUtil4DB();
}
}
//具体工厂，生产LogUtil4File
public class LogUtil4FileFactory extendsAbstractLogUtilFactory {
 
@Override
public ILogUtil create() {
return new LogUtil4File();
}
}</pre>
<p>
</p>
<h1>
	抽象工厂模式
</h1>
<p>
</p>
<p>
	此模式与工厂方法模式类似，但是较之多了一些产品，而且，这些产品不是ILogUtil的子类，比如DataSource，那么抽象方法也有些变化：多了生产DataSource的抽象方法。然后具体的工厂都会去实现或继承这个方法，达到生产DataSource的目的，实际上就是将两个不同的工厂方法模式进行合并。代码与工厂方法模式类似：
</p>
<p>
</p>
<pre name="code" class="java">//抽象工厂
public abstract classAbstractLogUtilFactory {
         publicabstract ILogUtil create()
public abstract IDataSource create();
}</pre>
<p>
</p>
<h1>
	总结
</h1>
<p>
</p>
<p>
	简单工厂与工厂方法模式类似，都是单一产品系的，因为工厂类中只定义了一种返回值类型的方法，而抽象工厂模式中定义了多种返回值类型的方法（不同的方法，返回值不同），实际上就是将两个不同的工厂方法模式进行合并。
</p>
<p>
	三种方式的关系简单表述为：由简单工厂衍生出工厂方法模式，通过将工厂类拆分成抽象工厂类（或接口）实现；由工厂方法模式衍生出抽象工厂模式，通过将两个不同产品系的工厂进行合并实现。
</p>
  </body>
</html>
